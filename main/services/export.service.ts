import { BrowserWindow, dialog, clipboard } from 'electron';
import fs from 'fs';
import { meetingsRepo } from '../database/repositories/meetings.repo';
import type { MeetingDetail } from '../../shared/types';

export const exportService = {
  generateMarkdown(meeting: MeetingDetail): string {
    const lines: string[] = [];

    lines.push(`# ${meeting.title}`);
    lines.push('');
    lines.push(`**Date:** ${new Date(meeting.started_at).toLocaleDateString('en-US', { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' })}`);
    if (meeting.duration_secs) {
      const mins = Math.round(meeting.duration_secs / 60);
      lines.push(`**Duration:** ${mins} minutes`);
    }
    if (meeting.notes?.meeting_type) {
      lines.push(`**Type:** ${meeting.notes.meeting_type}`);
    }
    lines.push('');

    // Attendees
    if (meeting.attendees.length > 0) {
      lines.push('## Attendees');
      for (const a of meeting.attendees) {
        lines.push(`- **${a.name}**${a.role ? ` - ${a.role}` : ''}`);
      }
      lines.push('');
    }

    // Executive Summary
    if (meeting.notes?.executive_summary) {
      lines.push('## Executive Summary');
      lines.push(meeting.notes.executive_summary);
      lines.push('');
    }

    // Key Takeaways
    if (meeting.notes?.key_takeaways?.length) {
      lines.push('## Key Takeaways');
      for (const t of meeting.notes.key_takeaways) {
        lines.push(`- ${t}`);
      }
      lines.push('');
    }

    // Discussion Topics
    if (meeting.notes?.discussion_topics?.length) {
      lines.push('## Discussion Topics');
      for (const topic of meeting.notes.discussion_topics) {
        lines.push(`### ${topic.title}`);
        lines.push(topic.summary);
        if (topic.details?.length) {
          lines.push('');
          for (const d of topic.details) {
            lines.push(`- ${d}`);
          }
        }
        lines.push('');
      }
    }

    // Action Items
    if (meeting.action_items.length > 0) {
      lines.push('## Action Items');
      for (const item of meeting.action_items) {
        const check = item.completed ? 'x' : ' ';
        const owner = item.owner ? ` (@${item.owner})` : '';
        const due = item.due_date ? ` [Due: ${item.due_date}]` : '';
        const priority = item.priority === 'high' ? ' **HIGH**' : '';
        lines.push(`- [${check}]${priority} ${item.description}${owner}${due}`);
      }
      lines.push('');
    }

    // Decisions
    if (meeting.decisions.length > 0) {
      lines.push('## Decisions');
      for (const d of meeting.decisions) {
        lines.push(`- **${d.description}**`);
        if (d.context) lines.push(`  - Context: ${d.context}`);
        if (d.decided_by) lines.push(`  - Decided by: ${d.decided_by}`);
      }
      lines.push('');
    }

    // Next Steps
    if (meeting.notes?.next_steps?.length) {
      lines.push('## Next Steps');
      for (const step of meeting.notes.next_steps) {
        lines.push(`- ${step}`);
      }
      lines.push('');
    }

    lines.push('---');
    lines.push(`*Generated by Mother's Notes*`);

    return lines.join('\n');
  },

  async exportMarkdown(meetingId: string): Promise<string> {
    const meeting = meetingsRepo.getDetail(meetingId);
    if (!meeting) throw new Error('Meeting not found');

    const markdown = this.generateMarkdown(meeting);

    const { filePath } = await dialog.showSaveDialog({
      title: 'Export Meeting Notes',
      defaultPath: `${meeting.title.replace(/[^a-zA-Z0-9]/g, '_')}.md`,
      filters: [{ name: 'Markdown', extensions: ['md'] }],
    });

    if (filePath) {
      fs.writeFileSync(filePath, markdown, 'utf-8');
      return filePath;
    }

    return '';
  },

  async exportPDF(meetingId: string): Promise<string> {
    const meeting = meetingsRepo.getDetail(meetingId);
    if (!meeting) throw new Error('Meeting not found');

    const markdown = this.generateMarkdown(meeting);

    // Create a hidden window to render and print to PDF
    const win = new BrowserWindow({
      show: false,
      width: 800,
      height: 600,
      webPreferences: { nodeIntegration: false, contextIsolation: true },
    });

    const html = `<!DOCTYPE html>
<html><head>
<style>
  body { font-family: -apple-system, BlinkMacSystemFont, sans-serif; max-width: 700px; margin: 40px auto; padding: 0 20px; color: #1a1a1a; font-size: 14px; line-height: 1.6; }
  h1 { font-size: 24px; border-bottom: 2px solid #e5e5e5; padding-bottom: 8px; }
  h2 { font-size: 18px; color: #333; margin-top: 24px; }
  h3 { font-size: 15px; color: #555; }
  ul { padding-left: 20px; }
  li { margin: 4px 0; }
  strong { color: #111; }
  hr { border: none; border-top: 1px solid #e5e5e5; margin: 24px 0; }
  em { color: #888; }
</style>
</head><body>${markdownToHtml(markdown)}</body></html>`;

    await win.loadURL(`data:text/html;charset=utf-8,${encodeURIComponent(html)}`);

    const { filePath } = await dialog.showSaveDialog({
      title: 'Export Meeting Notes as PDF',
      defaultPath: `${meeting.title.replace(/[^a-zA-Z0-9]/g, '_')}.pdf`,
      filters: [{ name: 'PDF', extensions: ['pdf'] }],
    });

    if (filePath) {
      const pdfBuffer = await win.webContents.printToPDF({
        printBackground: true,
        margins: { top: 0.5, bottom: 0.5, left: 0.5, right: 0.5 },
      });
      fs.writeFileSync(filePath, pdfBuffer);
      win.close();
      return filePath;
    }

    win.close();
    return '';
  },

  async exportClipboard(meetingId: string): Promise<void> {
    const meeting = meetingsRepo.getDetail(meetingId);
    if (!meeting) throw new Error('Meeting not found');
    const markdown = this.generateMarkdown(meeting);
    clipboard.writeText(markdown);
  },
};

// Simple markdown to HTML converter (enough for PDF export)
function markdownToHtml(md: string): string {
  return md
    .split('\n')
    .map((line) => {
      if (line.startsWith('### ')) return `<h3>${line.slice(4)}</h3>`;
      if (line.startsWith('## ')) return `<h2>${line.slice(3)}</h2>`;
      if (line.startsWith('# ')) return `<h1>${line.slice(2)}</h1>`;
      if (line.startsWith('---')) return '<hr>';
      if (line.startsWith('- [x] ')) return `<li>&#9745; ${inlineFormat(line.slice(6))}</li>`;
      if (line.startsWith('- [ ] ')) return `<li>&#9744; ${inlineFormat(line.slice(6))}</li>`;
      if (line.startsWith('- ')) return `<li>${inlineFormat(line.slice(2))}</li>`;
      if (line.trim() === '') return '<br>';
      return `<p>${inlineFormat(line)}</p>`;
    })
    .join('\n');
}

function inlineFormat(text: string): string {
  return text
    .replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>')
    .replace(/\*(.+?)\*/g, '<em>$1</em>');
}
